import sys
input = sys.stdin.readline

M = int(input())

start = 1
end = M * 10
ans = -1

while start <= end:
    mid = (start + end) // 2
    
    cnt = 0
    temp = mid
    while temp >= 5:
        cnt += temp // 5
        temp = temp // 5
    
    if cnt < M:
        start = mid + 1
    elif cnt == M:
        ans = mid
        end = mid - 1
    else:       
        end = mid - 1

print(ans)

# 0.5초만에 1억이면 시간 상 단순 반복으로는 통과하지 못할 듯 <- 이분 탐색 사용.
# 이라고 생각했지만, 이분 탐색을 안 쓰고 푸는 것부터 생각해보기.
# 5! = 120 0 1개  10! = 3628800 0 2개 15! = 130767436800 0 3개
# 5의 배수마다 0의 개수가 증가하는 중. M * 5 <- 틀렸음. 꼼수 실패

# 예제를 보니 5인 경우, -1이 출력됨.
# 5의 배수개는 -1인가? 아님. 45!이 0 10개를 가짐. 11이 -1임. 12는 50!

# 10이 곱해지는 경우 0이 생김. 10 <= 2*5 
# ! 에서 5!은 1*2*3*4*5 <= 2*5 1개 존재
# 10! 1*2*3*4*5*6*7*8*9*10 <= 2*5, 10으로 2개 존재.
# 15! 1*2*3*4*5*6*7*8*9*10*11*12*13*14*15 <= 2*5, 10, 12*15 3개 존재.
# 25 에서는 2*5, 10, 12*15, 22*25(5*5) <= 5의 개수가 6개. 6개 존재.
# 5의 개수가 즉 0의 개수로 정리.

# 대충 1에서 M * 100 사이에서 이분 탐색으로 돌면서 0의 개수를 세서 M개이면 그 값이 출력되게끔.
# 이분 탐색하면서 0의 개수 세기. 반복. <- 오답.
# cnt == M 인 시점에서 바로 나오면 가장 작은 값이 아니라 첫번째로 만난 값이 되어버림. 끝까지 돌아야 함.